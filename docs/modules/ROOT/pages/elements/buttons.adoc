= Buttons

include::../common.adoc[]

== Overview

Buttons are used to trigger actions or events. Buttons in the Elements
Library are stylable with separate elements for behavior and appearance.
Three types of buttons are available: momentary, toggle, and latching:

Momentary buttons ::
    Buttons that stay on while clicked. They are typically used to trigger an
    action.
Toggle buttons ::
    Buttons that alternate their state with each press. They are used to
    switch between two states.
Latching buttons ::
    Buttons are buttons that stay on until programmatically reset.

These classes delegate the rendering to a button styler subject. This
division of responsibilities allows for more flexibility in dictating the
button's appearance and interaction. The button classes handle user
interactions, while the button styler manages the button's visual
presentation. With this pattern, different stylers can be implemented for
various visual representations, for instance, plain buttons, radio buttons,
slide switches, checkboxes, and more.

=== Declaration

[,c++]
----
class basic_button;           // Base class for momentary buttons
class basic_toggle_button;    // Base class for toggle buttons
class basic_latching_button;  // Base class for latching buttons
----

=== Concepts

[,c++]
----
namespace concepts
{
   template <typename T>
   concept MomentaryButton = std::is_base_of_v<basic_button, std::decay_t<T>>;

   template <typename T>
   concept ToggleButton = std::is_base_of_v<basic_toggle_button, std::decay_t<T>>;

   template <typename T>
   concept LatchingButton = std::is_base_of_v<basic_latching_button, std::decay_t<T>>;

}
----

=== Notation

`styler`:: Styler instance that conforms to the Element concept.
`MBase`:: Type that conforms to the MomentaryButton concept.
`TBase`:: Type that conforms to the ToggleButton concept.
`LBase`:: Type that conforms to the LatchingButton concept.

=== Expressions

[,c++]
----
// Basic default buttons
momentary_button(styler);
toggle_button(styler);
latching_button(styler);

// Custom buttons
momentary_button<MBase>(styler);
toggle_button<TBase>(styler);
latching_button<LBase>(styler);
----

=== Semantics

. `momentary_button`
      is a function that creates a momentary button with the given styler
      element. `MBase`, if provided, is the base type that must conform to
      the `MomentaryButton` concept.
. `toggle_button`
      is a function that creates a toggle button with the given styler
      element. `TBase`, if provided,  is the the base type that must conform
      to the `ToggleButton` concept.
. `latching_button`
      is a function that creates a latching button with the given styler
      element. `LBase`, if provided,  is the the base type that must conform
      to the `LatchingButton` concept.

The provided base types `MBase`, `TBase`, and `LBase` offer the flexibility
to use custom button behavior, provided they adhere to their respective
concepts.

== Button Styler

NOTE: This section is an advanced topic only relevant to those who want to
write custom buttons. This section may be skipped by most users.

The button styler is a separate element that is responsible for rendering the
button. The communication with the button styler is done via the
`receiver<button_state>` or a `receiver<int>` APIs. These APIs provide a
means to update the button styler about changes in button's state to allow
the styler to adjust the visual representation accordingly.

If the button styler follows a `receiver<int>` API, it will receive in
integer with these possible values:

----
   0: value=false, hilite=false
   1: value=false, hilite=true
   2: value=true,  hilite=false
   3: value=true,  hilite=true
----

If the button styler follows a `receiver<button_state>` API, it will receive
a `button_state` when the button's state changes. This has a richer API
compared to the former, allowing more nuanced button rendering:

=== button_state

[,c++]
----
struct button_state
{
   bool              value : 1      = false;
   bool              hilite : 1     = false;
   bool              tracking : 1   = false;
   bool              enabled : 1    = true;
};
----

`button_state` is struct struct for maintaining and managing the state of a
button. This structure captures the various states that a button can have:

- `value`: The button's value; 0(off) or 1(on).
- `hilite`: True if the button is highlighted.
- `tracking`: True if the mouse button being pressed.
- `enabled`: True if the button is enabled.


NOTE: The button styler is just an element and does not have to follow the
`receiver` API. If that's the case, then the button rendering will be static,
and not adjust to state changes. This may still be useful in certain cases.

'''

_Copyright (c) 2014-2024 Joel de Guzman. All rights reserved._
_Distributed under the {mit_license}_