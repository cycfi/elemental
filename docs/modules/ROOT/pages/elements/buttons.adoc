= Buttons

include::../common.adoc[]

== Overview

Buttons are used to trigger actions or events. Buttons in the Elements
Library are stylable with separate elements for behavior and appearance.
Three types of buttons are available: momentary, toggle, and latching:

Momentary buttons ::
    Buttons that stay on while clicked. They are typically used to trigger an
    action.
Toggle buttons ::
    Buttons that alternate their state with each press. They are used to
    switch between two states.
Latching buttons ::
    Buttons are buttons that stay on until programmatically reset.

These classes delegate the rendering to a button styler subject. This
separation of responsibilities provides greater flexibility in defining the
button's appearance and behavior. The button classes handle user
interactions, while the button styler manages the button's visual
presentation. With this pattern, different stylers can be implemented for
various visual representations, for instance, plain buttons, radio buttons,
slide switches, checkboxes, and more.

=== Declaration

[,c++]
----
class basic_button;           // Base class for momentary buttons
class basic_toggle_button;    // Base class for toggle buttons
class basic_latching_button;  // Base class for latching buttons
----

=== Concepts

[,c++]
----
namespace concepts
{
   template <typename T>
   concept MomentaryButton = std::is_base_of_v<basic_button, std::decay_t<T>>;

   template <typename T>
   concept ToggleButton = std::is_base_of_v<basic_toggle_button, std::decay_t<T>>;

   template <typename T>
   concept LatchingButton = std::is_base_of_v<basic_latching_button, std::decay_t<T>>;

}
----

=== Notation

`styler`:: Styler instance that conforms to the Element concept.
`MBase`:: Type that conforms to the MomentaryButton concept.
`TBase`:: Type that conforms to the ToggleButton concept.
`LBase`:: Type that conforms to the LatchingButton concept.


=== Expressions

[cols="2,3", options="header"]
|===
| Expression | Semantics

a|
[source,c++]
----
momentary_button(styler);
----
a|
* Creates a momentary button with the given styler element.

a|
[source,c++]
----
toggle_button(styler);
----
a|
* Creates a toggle button with the given styler element.

a|
[source,c++]
----
latching_button(styler)
----
a|
* Creates a latching button with the given styler element.

a|
[source,c++]
----
momentary_button<MBase>(
   styler
)
----
a|
* Creates a momentary button with the given styler element.
* `MBase` is the base type that must conform to the `MomentaryButton`
   concept.

a|
[source,c++]
----
toggle_button<TBase>(
   styler
)
----
a|
* Creates a toggle button with the given styler element.
* `TBase` is the base type that must conform to the `ToggleButton` concept.

a|
[source,c++]
----
latching_button<LBase>(
   styler
)
----
a|
* Creates a latching button with the given styler element.
* `LBase` is the base type that must conform to the `LatchingButton` concept.
|===

The provided base types `MBase`, `TBase`, and `LBase` offer the flexibility
to use custom button behavior, provided they adhere to their respective
concepts.

== On Click

Buttons include an `on_click` callable object, which is called whenever the
button is clicked.

=== Notation

`btn`:: A Button instance.
`f`  :: A callback function with the signature `void(bool state)`.

=== Expressions

[cols="2,3", options="header"]
|===
| Expression | Semantics

a|
[source,c++]
----
btn.on_click = f;
----
a|
* Assigns a callable function, `f`, to the button's `on_click` event.
* The `on_click` callback is called at the trailing edge of the click, just
  before release.
* Momentary and latching buttons will always have a state of `true` when
  its `on_click` callback is called.
* Toggle buttons will will have a state that alternates between `true` and
  `false` with each click.
|===

The client provides a callback function, typically a c++ lambda, that will be
called when the button is clicked. The type of the `on_click` callable object
is:

[source,c++]
----
std::function<void(bool state)>
----

The `state` argument indicates whether the button is ON (`true`) or OFF
(`false`).

=== Example

[,c++]
----
btn.on_click =
   [](bool state)
   {
      std::cout << "Button clicked: " << state << std::endl;
   };
----

== Enable/Disable

Buttons can be enabled or disabled. When disabled, the button will not
respond to user clicks and, if the button styler handles it, will render
differently to indicate that it is disabled.

=== Notation

`btn` :: A Button instance.
`state`  :: A boolean value indicating whether the button is enabled or disabled.

=== Expressions

[cols="2,3", options="header"]
|===
| Expression | Semantics

a|
[source,c++]
----
btn.enable(state)
----
a|
* Sets the button's enabled state. Pass `true` to the `state` argument to
  enable the button, or `false` to disable it.
* When disabled, the button will not respond to clicks.
a|
[source,c++]
----
btn.is_enabled()
----
a|
* Returns `true` if the button is enabled, `false` otherwise.
|===

== Value

The value of a button is a boolean that indicates whether the button is ON
(`true`) or OFF (`false`). The value of a button can be set programmatically
via the `{receiver}<bool>` API.

NOTE: {receiver}<T> is mixin class that provides a common interface for
setting and querying the values of type `T` via virtual member
functions, `value()` and `value(val)`.

=== Notation

`btn`    :: A Button instance.
`val`    :: A boolean value.

=== Expressions

[cols="2,3", options="header"]
|===
| Expression | Semantics

a|
[source,c++]
----
btn.value(val)
----
a|
* Sets the value of the button to `val`.

a|
[source,c++]
----
btn.value()
----
a|
* Returns the current value of the button.
|===

== Button Styler

NOTE: This section is an advanced topic only relevant to those who want to
write custom buttons. This section may be skipped by most users.

The button styler is a separate element that is responsible for rendering the
button. The communication with the button styler is done via the
`{receiver}<button_state>` API. This API provides a means to update the button
styler about changes in button's state to allow the styler to adjust the
visual representation accordingly.

If the button styler is as a subclass of `{receiver}<button_state>` API, it
will receive a `button_state` when the button's state changes:

=== button_state

[,c++]
----
struct button_state
{
   bool    value : 1      = false;
   bool    hilite : 1     = false;
   bool    tracking : 1   = false;
   bool    enabled : 1    = true;
};
----

`button_state` is struct struct for maintaining and managing the state of a
button. This structure captures the various states that a button can have:

- `value`: The button's value; 0(off) or 1(on).
- `hilite`: True if the button is highlighted (when the mouse is
   hovering over the button).
- `tracking`: True if the mouse button being pressed.
- `enabled`: True if the button is enabled.


NOTE: The button styler is just an element and does not have to follow the
`{receiver}` API. If that's the case, then the button rendering will be static,
and not adjust to state changes. This may still be useful in certain cases.

'''

_Copyright (c) 2014-2024 Joel de Guzman. All rights reserved._
_Distributed under the {mit_license}_